# Onboarding

## 1. Project Structure

### Root

1.1  
The root of the project follows the basic form generated by create-react-app which is industry standard. This is as follows:

my-app  
├── README.md  
├── node_modules  
├── package.json  
├── .gitignore  
├── public  
│   ├── favicon.ico  
│   ├── index.html  
│   ├── logo192.png  
│   ├── logo512.png  
│   ├── manifest.json  
│   └── robots.txt  
└── src  
    ├── App.css  
    ├── App.tsx  
    ├── index.css  
    ├── index.ts  
    ├── logo.svg  
    └── serviceWorker.ts

1.2  
This project uses typescript. Files which do not contain React components have the .ts extension, files which do have .tsx.

1.3  
Typescript is seamlessly handled by this project's bootstrap to create-react-app. Write any file normally and create-react-app will generate it in the dev server, as well as compile type mappings in production builds.

### Components

1.4  
The majority of project components follow a specific structure formulated by Aloysius. Related components are put in a shared folder in `src`, ex: `src/tournaments/`.

Within this folder, the structure is as follows:

src/tournament/  
├── css/  
├── hooks/  
├── index.ts(x)  
├── ComponentA.tsx   
├── ComponentB.tsx  
├── [...]

1.5  
The css/ folder contains `.module.css` corresponding to a specific `.tsx` file each. This allows for some really carefully-managed, meticulous, custom styles. See section **CSS** for more information.

1.6  
The hooks/ folder contains various .ts or .tsx reusable hooks that are called by several components. Any complex state logic is also placed in these hooks. See section **Functional Components** for more information.

1.7  
Most directories will contain an index.ts file. This tends to be an index file which imports every every component in its directory on the same level. This allows for two useful features:
- Group importing, for example:
```ts
import { User, Profile, Pairings } from './Tournament'
```
- Autocompleted component imports

1.8  
From there, every related component will have its own .tsx file. Some components, if they are considered large enough 'sub-modules' of the set, for instance the *Pairings* sub-module of tournament, will have it's own subdirectory with the same directory structure, except that the `index.ts` file tends to be replaced by an `index.tsx`.

## 2. Components

2.1  
All components are React Functional components. The convention used in this project is to:
```tsx
export default function Component(props: ComponentProps): ReactElement {

	// internal component logic goes here

	//ReactElement
	return <></> 
}
```
where ComponentProps is an interface defined within the file and the function returns a ReactElement. This helps to keep everything nice and tidy.

2.2  
Interfaces are how to re-use types generated for type-checking with typescript.
Other interfaces are stored elsewhere for other data structures. Those received from the backend are stored in `src/interfaces.ts`.

2.3  
Types for third-party packages come in three forms:
- The author has written them already as native to the package (the package ships with an index.d.ts), in which case `npm install package-name` is all you need to do.
- The author has written them as an add-on installation, in which case after the above install, you also need to retrive `npm install @types/package-name --save-dev`.
- We need to write the types for the packages ourselves.

Custom module types follow the same syntax and it's fairly intuitive. Best just to follow an existing type declaration written out there. Types for this project are stored in `src/@types/**.d.ts`

## 3. Styles

3.1  
As already mentioned, styles are stored in `*.module.css` files within the same level directory as the corresponding .tsx file. Module.css files get rendered to uniquely generated classnames at run-time without the need for additional DOM properties.

3.2  
Import a classname for an element by using:
```html
<div className={styles.myElement} />
```
or, if multiple classnames are used, 
```tsx
import classnames;

<div className={cx(styles.myElement, styles.secondClass)} />
```

3.3  
We use camelCase for all classnames and variable names.

3.4  
We use pascal case for all component names. This convention should become fairly obvious on working this codebase.

3.5  
There is also a convention to name the *outermost* div on a sheet `.container`, the inner wrapper for that div `.stage`, and anything else fairly literal names, such as `.button` for buttons within the sheet. The reason why this works is because with .module.css, classname namespaces can be reused since they are rendered uniquely for each element.

3.6  
We avoid inline styles wherever possible.